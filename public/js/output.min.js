function loadGoogleAutocomplete(){

        setTimeout(function() {

            // default autoComplete bounds to Logan city area
            var defaultBounds = new google.maps.LatLngBounds(
              new google.maps.LatLng(-27.641505, 153.106308));

            var options = { bounds: defaultBounds };

            var startAddress = new google.maps.places.Autocomplete(document.getElementById('start-address'), options);
            var destAddress = new google.maps.places.Autocomplete(document.getElementById('dest-address'), options);

            setGoogleListener(startAddress, 'start');
            setGoogleListener(destAddress, 'dest');

    }, 1000);
}

function setGoogleListener(control, name){
    
    google.maps.event.addListener(control, 'place_changed', function () {
                
        var place = control.getPlace();
        var address = place.formatted_address;
        if (!place.geometry) {
            console.debug("Google Maps API call returned an empty address, please try to provide an other place");
            return;
        }
        var latitude = place.geometry.location.lat();
        var longitude = place.geometry.location.lng();
            
        getLocationInfo(latitude, longitude).then(
            function (info) {
                setAddressDetails(name, latitude, longitude, info.postCode, info.suburb);
            }, 
            function (err) {
                console.debug('An error occurred during postcode resolution.', err);
            }
        ); 
    });
    
    $("#dest-address").keydown(function () {
        setAddressDetails('dest', '','','','');        
    });
    $("#start-address").keydown(function () {
        setAddressDetails('start', '','','','');
    });

}

function setAddressDetails(name, lat, long, postcode, suburb){
    document.getElementById(name + "PostCode").value = postcode;                        
    document.getElementById(name + "Suburb").value = suburb;                        
    document.getElementById(name + "AddressLat").value = lat;
    document.getElementById(name + "AddressLong").value = long;
}

function readPostalCode(place) {

    var outOfBoundAddress = false;
    var postcode = '';
    for (var i = 0; i < place.address_components.length; i++) {
        var addressType = place.address_components[i].types[0];    
        if (addressType === 'country' && 'Australia' !== place.address_components[i].long_name) {
            outOfBoundAddress = true;
            break;            
        } 
        if (addressType === 'postal_code') {
            postcode = place.address_components[i].short_name;
        }
    }

    if (!outOfBoundAddress) {
        return postcode;
    }

    return '';    
}

function readSuburb(place) {

    var suburb = '';
    for (var i = 0; i < place.address_components.length; i++) {
        if(place.address_components[i].types.length == 2) {
            if(place.address_components[i].types[0] === 'locality' && place.address_components[i].types[1] === 'political') {
                suburb = place.address_components[i].short_name;
                break;
            }
        }
    }
    return suburb;
}

function getLocationInfo(latitude, longitude) {
    var deferred = $.Deferred(),
        geocoder = new google.maps.Geocoder;
        
    geocoder.geocode(
        {'location': {lat: latitude, lng: longitude} }, 
        function(results, status) {
            var postcode = '';
            if (status === google.maps.GeocoderStatus.OK && results.length > 0) {
                for (var i = 0; i < results.length; i++) {
                    postcode = readPostalCode(results[i]);
                    if ('' != postcode) {
                        var suburb = readSuburb(results[i]);
                        deferred.resolve( { 'postCode': postcode, 'suburb': suburb } );
                        break;
                    }
                }
            }
            if (postcode == '') {
                deferred.reject(status);
            }   
        }
    );

    return deferred.promise();
}
;var loganPostcodes = ['4114', '4117', '4118','4119','4123','4124','4125','4127','4128','4129','4130','4131','4132','4133','4205','4207','4270','4280','4285']

function validateAddresses(){
	var startPC = document.getElementById("startPostCode").value;
	var startLat = document.getElementById("startAddressLat").value;
	var startLong = document.getElementById("startAddressLong").value;
	var destPC = document.getElementById("destPostCode").value;
	var destLat = document.getElementById("destAddressLat").value;
	var destLong = document.getElementById("destAddressLong").value;
	var errors = [];
	
	if (!startLat || !startLong || !startPC) {
		errors.push("<li>Start address invalid or not found</li>");
	}
	if (!destLat || !destLong || !destPC) {
		errors.push("<li>Destination address invalid or not found</li>");
	}		
						
	if (!addressWithinLoganRegion(startPC) && !addressWithinLoganRegion(destPC)) {
		errors.push("<li>At this point we require at least one address to be within the Logan city bounds.</li>");
	}

	if (bothAddressesAreIdentical(startLat, startLong, destLat, destLong)){
		errors.push("Please enter two different addresses");
	}

	if (errors.length > 0) {	
		document.getElementById("validation-errors").innerHTML = 'There were errors in the information entered: <ul>' + errors.join('') + '</ul>';
		return false;
	}
	
	document.getElementById("validation-errors").innerText = '';
	return true;
}

function addressWithinLoganRegion(postcode)
{
	return loganPostcodes.indexOf(postcode) > -1;
}

function bothAddressesAreIdentical(startLat, startLong, destLat, destLong){
	var addressesIdentical = false;

	if (startLat === destLat && startLong === destLong)
		addressesIdentical = true;

	return addressesIdentical;
};var app = angular.module('bus-meme', ['ngRoute', 'bus-meme.config']);

app.config(function ($routeProvider, $locationProvider) {
    $routeProvider.
    when('/', {
        redirectTo: '/logan'
    }).
    when('/logan', {
        templateUrl: 'views/main.html',
        controller: 'MapController'
    }).
    when('/logan/galleries', {
        templateUrl: 'views/gallery.html',
        controller: 'GalleryController'
    }).
    when('/logan/about', {
        templateUrl: 'views/about.html',
        controller: 'AboutController'
    }).
    when('/logan/meme', {
        templateUrl: 'views/image-viewer.html',
        controller: 'ImageViewController'
    }).
    when('/export', {
        templateUrl: 'views/export.html',
        controller: 'ExportController'
    })
    .otherwise({ redirectTo: '/logan' });

    $locationProvider.html5Mode(true);
});

app.factory('locationUtil', function($location) {
    return {
        getLocationPath: function () {
            var host = $location.host(),
                protocol = $location.protocol(),
                port = $location.port(),
                path = $location.path();
            var locationPath;
            if (port) {
                locationPath = protocol + '://' + host + ':' + port + path;
            } else {
                locationPath = protocol + '://' + host + path;
            }
            return locationPath;
        }
    }
});

;var app = angular.module('bus-meme');

app.controller('MapController', function ($scope, $location, $rootScope, MapService, $anchorScroll, BusMemeConfig, FacebookService, locationUtil, $q, $http) {
    FacebookService.initialiseFacebook();

    loadGoogleAutocomplete();

    $scope.transport = {
        mode: 'driving',
        preference: 'speed'
    };

    $scope.showImage = false;
    $scope.showMap = false;
    $scope.memeNotSelected = false;
    $scope.showImgOut = false;

    $scope.canProgressToStage2 = true;
    $scope.canProgressToStage3 = false;

    $scope.origin = null;
    $scope.destination = null;

    $scope.ptLatLng = [];
    $scope.dwLatLng = [];

    $scope.dwBounds = null;
    $scope.ptBounds = null;

    $scope.map = null;

    var getGoogleRoute = function (mode, startLat, startLng, endLat, endLng) {

        var d = $q.defer();

        var travelOptions = {
            startLat: startLat,
            startLng: startLng,
            destLat: endLat,
            destLng: endLng
        };

        var routeDetails = {};
        MapService.getDirections(travelOptions, mode, function (result, status) {
            if (status == google.maps.DirectionsStatus.OK) {
                routeDetails['distance'] = result.routes[0].legs[0].distance.text;
                routeDetails['duration'] = result.routes[0].legs[0].duration.text;

                var latLng = []
                var currentMode = "";
                var totalWalkingDistance = 0;
                routeDetails['polylineCoords'] = []

                result.routes.forEach(function (route) {
                    route.legs.forEach(function (leg) {
                        leg.steps.forEach(function (step) {
                            var travelMode = step.travel_mode.toLowerCase();
                            if (travelMode !== currentMode) {
                                if (latLng.length > 0) {
                                    routeDetails['polylineCoords'].push({"mode": currentMode, "coords": latLng})
                                    latLng = [];
                                }
                                currentMode = travelMode;
                                if ('walking' == currentMode) {
                                    totalWalkingDistance += step.distance.value;
                                }
                            }
                            step.path.forEach(function (path) {
                                latLng.push({lat: path.lat(), lng: path.lng()});
                            });
                        });
                    });
                });

                if (latLng.length > 0) {
                    routeDetails['polylineCoords'].push({"mode": currentMode, "coords": latLng})
                }
                routeDetails['bounds'] = result.routes[0].bounds;
                if ('transit' === mode) {
                    routeDetails['distance'] = totalWalkingDistance;
                }
                d.resolve(routeDetails);
            } else {
                d.resolve(null);
            }
        });
        return d.promise;
    }

    var clearStatus = function () {
        $('#map-status').html('');
    };

    var addStatus = function (message) {
        $('#map-status').html($('#map-status').html() + "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" + message);
    };

    $scope.getMapData = function () {

        $scope.dwBounds = null;
        $scope.ptBounds = null;

        clearStatus()
        $('#map-status').show();
        addStatus('Building your meme, please be patient');
        $('#map-wrapper').show();

        $scope.public = {
            mode: 'public',
            distance: '',
            duration: ''
        };

        $scope.other = {
            mode: $scope.transport.mode,
            distance: '',
            duration: ''
        };

        if (validateAddresses()) {
            addStatus("Addresses are valid");
            var startLat = document.getElementById('startAddressLat').value,
                startLng = document.getElementById('startAddressLong').value,
                destLat = document.getElementById('destAddressLat').value,
                destLng = document.getElementById('destAddressLong').value;

            $scope.origin = new google.maps.LatLng(startLat, startLng);
            $scope.destination = new google.maps.LatLng(destLat, destLng);

            addStatus("Retrieving " + $scope.transport.mode + " directions from Google...");
            getGoogleRoute($scope.transport.mode, startLat, startLng, destLat, destLng).then(
                function (dwRoute) {
                    if (dwRoute) {
                        addStatus("Success!");
                        $scope.other = {
                            mode: $scope.transport.mode,
                            distance: distanceWithMeasure(dwRoute.distance),
                            duration: shorter(dwRoute.duration)
                        };

                        $scope.dwLatLng = dwRoute.polylineCoords;
                        $scope.dwBounds = dwRoute.bounds;
                        return { "dw": true, "pt": false };
                    }
                    addStatus("Failed to retrieve directions, please wait a moment and try again");
                    return { "dw": false, "pt": false };
                }
            ).then(
                function (directionsStatus) {

                    var d = $q.defer();

                    if (!directionsStatus.dw) { d.resolve( { "dw": false, "pt": "none" } ); return d.promise; }

                    addStatus("Retrieving journey information from Translink (allowing 10 seconds)...");
                    var tlapiUrl = locationUtil.getLocationPath() +
                        "/tl/" +
                        startLat + "/" +
                        startLng + "/" +
                        destLat + "/" +
                        destLng + "/" +
                        $scope.getTimeOption() + "/" +
                        $scope.getSelectedTime().getTime() / 1000 + "/" +
                        "4000/" +
                        $scope.transport.preference;

                    console.log(tlapiUrl, $scope.transport);

                    $.ajax({
                        type: "GET",
                        url: tlapiUrl,
                        timeout: 10000,
                        success: function (journey) {
                            if (!journey) {
                                addStatus("Failed to retrieve journey information");
                                d.resolve( { "dw": true, "pt": "none" } );
                                return;
                            }

                            addStatus("Success!");
                            $scope.public = {
                                mode: 'public',
                                distance: prettyDistance(journey.walkingDistance),
                                duration: prettyDuration(journey.duration)
                            };

                            $scope.ptLatLng = [];
                            if (journey.legs) {
                                journey.legs.forEach(function (leg) {
                                    var legLatLng = [];
                                    google.maps.geometry.encoding.decodePath(leg.polyline).forEach(function (ll) {
                                        legLatLng.push({"lat": ll.lat(), "lng": ll.lng()});
                                    });
                                    $scope.ptLatLng.push({"mode": leg.travelMode, "coords": legLatLng});
                                });
                            }

                            $scope.ptBounds = findPolylineBounds($scope.ptLatLng);
                            if($scope.getMaxWalk() < journey.walkingDistance) {
                                // will need to walk too far
                                d.resolve( { "dw": true, "pt": "badWalk" } );
                            } else {
                                d.resolve( { "dw": true, "pt": "transport" } );
                            }
                        },
                        error: function (err) {
                            addStatus("Journey could not be retrieved, trying Google...");
                            d.resolve( { "dw": true, "pt": "none" } );
                        }
                    });
                    return d.promise;
                }
            ).then(
                function (directionsStatus) {
                    var d = $q.defer();

                    if(!directionsStatus.dw ||                      // Driving failed
                        directionsStatus.pt === "badWalk" ||        // Walk was too far but PT available
                        directionsStatus.pt === "transport" ||      // Everything is OK
                        $scope.transport.mode === 'walking')        // No need to ask for walking directions twice
                    {
                        d.resolve(directionsStatus);
                        return d.promise;
                    }

                    $scope.ptLatLng = [];
                    addStatus("Retrieving walking directions from Google...");
                    getGoogleRoute('walking', startLat, startLng, destLat, destLng).then(
                        function (ptRoute) {
                            if (ptRoute) {
                                addStatus("Success!");
                                $scope.public = {
                                    mode: 'public',
                                    distance: 'Walk: ' + ptRoute.distance,
                                    duration: shorter(ptRoute.duration)
                                };
                                $scope.ptLatLng = ptRoute.polylineCoords;
                                $scope.ptBounds = ptRoute.bounds;
                                d.resolve( {"dw": true, "pt": "walk"} );
                            } else {
                                d.resolve( {"dw": true, "pt": "none"} );
                                addStatus("Failed to retrieve walking directions");
                            }
                        }
                    );                    
                    return d.promise;
                }
            ).then(
                function(directionsStatus) {
                    if(directionsStatus.dw) {
                        $scope.mapToImage(directionsStatus.pt);
                    } else {
                        // everything failed
                        addStatus("Sorry, there was an error. PLease try again later");
                    }
                }
            );

            initStep2();
            scrollToElement('invisible-anchor');
            $scope.showMap = true;

        } else {
            addStatus("Invalid addresses");
            $scope.showMap = false;
        }
    };

    var renderStaticMap = function (ptRouteProperties) {

        var gmapsInfo = getMapConversionInfo();

        var staticMapsUrl = BusMemeConfig.GOOGLE_MAP_STATIC_URL,
            mapCenter = 'center=' + $scope.center.lat() + ',' + $scope.center.lng(),
            zoomLevel = 'zoom=' + $scope.zoom,
            mapSize = 'size=' + $scope.mapWidth + 'x' + $scope.mapWidth;

        var imgUrl = staticMapsUrl + mapCenter + '&' + zoomLevel + '&' + mapSize;

        var image = document.getElementById('img-out');
        image.setAttribute('crossorigin', 'anonymous');
        image.setAttribute('src', imgUrl);

        $("#img-out").load(function () {

            var canvas = document.getElementById("canvas");
            var context = canvas.getContext("2d");
            context.clearRect(0, 0, canvas.width, canvas.height);

            $rootScope.context = context;
            canvas.width = image.width;
            canvas.height = image.height * 1.3;
            context.drawImage(image, 0, 0, canvas.width, image.height);

            var lineWidth = 2;

            var ptRouteColor = '#FF0000';
            var otherRouteColor = '#0000FF';
            var markerColor = '#006400';
            var marker2Color = '#FF0000';

            drawCircleAt($scope.origin, context, markerColor, gmapsInfo)
            drawCircleAt($scope.destination, context, marker2Color, gmapsInfo)

            if (ptRouteProperties !== "none") {
                drawPolylines($scope.ptLatLng, context, lineWidth, ptRouteColor, gmapsInfo);
            }
            drawPolylines($scope.dwLatLng, context, lineWidth, otherRouteColor, gmapsInfo);

            drawLegend(context, gmapsInfo, image.height, canvas.width, canvas.height - image.height, image.height);

            drawMapSummary(context, ptRouteProperties, image.width / 2, image.height + 20, ptRouteColor, otherRouteColor, markerColor);

            $('#gmap-canvas').html("");
            $('#map-status').hide();
            $('#map-wrapper').hide();
            $scope.$apply(function () {
                $scope.canProgressToStage3 = true;
                $rootScope.showTemplates = true;
            });
        });
    };

    $scope.mapToImage = function (ptRouteProperties) {
        $scope.mapWidth = 600;
        if (ptRouteProperties !== "none") {
            $scope.bounds = getCombinedBounds([$scope.ptBounds, $scope.dwBounds]);
        } else {
            $scope.bounds = getCombinedBounds([$scope.dwBounds]);
        }

        $scope.center = $scope.bounds.getCenter();
        $scope.zoom = getZoom($scope.bounds, $scope.mapWidth);

        var mapOptions = {
            zoom: $scope.zoom,
            center: $scope.center,
            mapTypeId: google.maps.MapTypeId.ROADMAP
        };

        $('#map-wrapper').show();
        $scope.map = new google.maps.Map(document.getElementById("gmap-canvas"), mapOptions);

        google.maps.event.addListenerOnce($scope.map, 'idle', function () {
            if ($scope.map.getZoom() != $scope.zoom) {
                google.maps.event.addListenerOnce($scope.map, "zoom_changed", function () {
                    renderStaticMap(ptRouteProperties);
                });
                $scope.map.setZoom($scope.zoom);
            } else {
                renderStaticMap(ptRouteProperties);
            }
        });
    };

    var writeTextOnImage = function (context, lineWidth, text, x, y) {

        var f = 36;
        for (; f >= 0; f -= 1) {
            context.font = "bold " + f + "pt Impact, Charcoal, sans-serif";
            if (context.measureText(text).width < canvas.width - 10) {
                context.textAlign = "center";
                context.fillStyle = "white";
                context.strokeStyle = "black";
                context.lineWidth = lineWidth;
                context.fillText(text, x, y);
                context.strokeText(text, x, y);

                break;
            }
        }
    };

    var drawLegend = function (context, gmapsInfo, yStart, width, height, imageHeight) {

        var lineHeight = 3;

        context.beginPath();
        context.rect(1, 0, width - 2, yStart);
        context.strokeStyle = '#000000';
        context.lineWidth = lineHeight;
        context.stroke();

        context.beginPath();
        context.rect(1, yStart, width - 2, height - 1);
        context.fillStyle = '#E8E5DC';
        context.fill();
        context.strokeStyle = '#000000';
        context.lineWidth = lineHeight;
        context.stroke();
    };

    var drawMapSummary = function (context, ptRouteProperties, x, y, ptColour, otherColour, walkingColour) {

        var fontSize = '24';
        var fontFace = 'Helvetica';
        context.textAlign = "center";
        context.lineHeight = 24;
        
        context.fillStyle = "black";
        
        if(ptRouteProperties !== "transport") { context.fillStyle = "red"; }
        context.font = "bold " + fontSize + 'px ' + fontFace;
        context.fillText(getEndpointSummary(ptRouteProperties==="transport"), x, y + 8);

        context.fillStyle = "black";
        fontSize = 14;
        context.font = fontSize + 'px ' + fontFace;
        context.fillText(getMaxWalkSummary(), x, y + 30);

        fontSize = 20;
        context.font = fontSize + 'px ' + fontFace;
        context.fillText(getUserTimeSelectionHeader(), x, y + 60);

        context.fillText(getOtherModeHeader() + getOtherModeSummary(), x, y + 90);

        context.fillText(getPublicTransportSummary(ptRouteProperties), x, y + 120);

        drawMapSummaryLegends(context, x, y + 141, ptColour, otherColour, walkingColour);
    };

    var drawMapSummaryLegends = function (context, x, legendsY, ptColour, otherColour, walkingColour) {
        context.font = "14px Helvetica";
        context.textAlign = "left";

        var legendText = 'public transport';

        var lineWidth = 25;
        var nextLegendIndex = 25;
        drawSummaryLegend(context, nextLegendIndex, legendsY, nextLegendIndex + lineWidth, legendsY, [], ptColour, 3);
        context.fillText(legendText, nextLegendIndex + 35, legendsY + 5);
        
        nextLegendIndex = 170 + context.measureText(legendText).width;
        drawSummaryLegend(context, nextLegendIndex, legendsY, nextLegendIndex + lineWidth, legendsY, [5], walkingColour, 4);
        legendText = 'walking';
        context.fillText(legendText, nextLegendIndex + 35, legendsY + 5);

        nextLegendIndex = 170 + nextLegendIndex + context.measureText(legendText).width;
        drawSummaryLegend(context, nextLegendIndex, legendsY, nextLegendIndex + lineWidth, legendsY, [], otherColour, 3);
        legendText = "driving";
        context.fillText(legendText, nextLegendIndex + 35, legendsY + 5);
    }
    var drawSummaryLegend = function (context, startX, startY, endX, endY, lineDash, lineColour, lineWidth) {

        context.beginPath();
        context.moveTo(startX, startY);
        context.lineTo(endX, endY);

        context.setLineDash(lineDash);
        context.strokeStyle = lineColour;
        context.lineWidth = lineWidth;

        context.stroke();
    };

    var getEndpointSummary = function (ptRouteIsValid) {
        var startSuburb = document.getElementById('startSuburb').value,
            destSuburb = document.getElementById('destSuburb').value;
        var ret = startSuburb + " to " + destSuburb;
        if(ptRouteIsValid) { return ret; }
        return "No service from " + ret;
    };

    var getMaxWalkSummary = function () {
        var walk = parseInt($scope.getMaxWalk());
        if(walk < 1000) {
            walk = walk + " m";
        } else {
            walk = Math.floor(walk/100)/10 + " km";
        }
        return "(with max walk: " + walk + ")";
    };

    var getUserTimeSelectionHeader = function () {
        var transportChoice = $scope.formattedTimeOption();
        var date = $scope.formattedDate();
        return transportChoice + ' on ' + date;
    };

    var getPublicTransportSummary = function (ptRouteProperties) {

        if (ptRouteProperties==="transport") {
            return 'PUBLIC TRANSPORT: ' + $scope.public.duration + ', ' + $scope.public.distance;
        } else if (ptRouteProperties==="badWalk") {
            return 'PUBLIC TRANSPORT: ' + $scope.public.duration + ', ' + $scope.public.distance;
        } else {
            if($scope.public.duration !== '') {
                return "You could try walk: " + ("" +$scope.public.distance).replace("Walk: ", "") + " for " + $scope.public.duration;
            }
        }
        return '';
    };
    var getOtherModeHeader = function () {
        return $scope.other.mode.toUpperCase() + ': ';
    };
    var getOtherModeSummary = function () {
        return $scope.other.duration + ', ' + $scope.other.distance;
    };
    var drawCircleAt = function (center, context, color, gmapsInfo) {
        context.beginPath();
        context.strokeStyle = color;
        context.lineWidth = 5;
        var centerXy = getXYcoords(gmapsInfo, center);
        context.arc(centerXy[0], centerXy[1], 8, 0, 2 * Math.PI);
        context.stroke();
    };

    var drawPolylines = function (polylineData, context, lineWidth, lineColor, gmapsInfo) {

        polylineData.forEach(function (polyline) {
            var latLngArray = polyline['coords'];
            var startCoords = getXYcoords(gmapsInfo, new google.maps.LatLng(latLngArray[0].lat, latLngArray[0].lng));

            context.beginPath();
            context.moveTo(startCoords[0], startCoords[1]);
            for (i = 1; i < latLngArray.length; i++) {
                var coord = getXYcoords(gmapsInfo, new google.maps.LatLng(latLngArray[i].lat, latLngArray[i].lng));
                context.lineTo(coord[0], coord[1]);
            }

            if (polyline['mode'] == 'walking') {
                context.setLineDash([5]);
                context.strokeStyle = "#006400";
                context.lineWidth = 4;
            } else {
                context.setLineDash([]);
                context.strokeStyle = lineColor;
                context.lineWidth = lineWidth;
            }
            context.stroke();
        });

        // Reset line dash to fix bug with frame being dotted 
        context.beginPath();
        context.setLineDash([]);
    };

    $scope.renderMemeFinal = function () {
        var context = $rootScope.context;
        var image = document.getElementById('img-out');
        var topText = $rootScope.selectedTemplate.firstLine;
        var bottomText = $rootScope.selectedTemplate.secondLine;

        var width = image.width;
        var height = image.height;
        context.textAlign = "center";
        context.fillStyle = "white";
        context.strokeStyle = "black";
        var lineWidth = 2;
        writeTextOnImage(context, lineWidth, topText, width / 2, 70);
        writeTextOnImage(context, lineWidth, bottomText, width / 2, height - 30);

        $('canvas2').remove();
        $rootScope.memeText = $rootScope.selectedTemplate.firstLine + ' - ' + $rootScope.selectedTemplate.secondLine;

    };

    var getZoom = function (bounds, mapWidth) {
        //https://stackoverflow.com/a/13274361
        var WORLD_DIM = {height: 256, width: 256};
        var ZOOM_MAX = 21;

        function _latRad(lat) {
            var sin = Math.sin(lat * Math.PI / 180);
            var radX2 = Math.log((1 + sin) / (1 - sin)) / 2;
            return Math.max(Math.min(radX2, Math.PI), -Math.PI) / 2;
        }

        function _zoom(mapPx, worldPx, fraction) {
            //return Math.log(mapPx / worldPx / fraction) / Math.LN2;
            return Math.floor(Math.log(mapPx / worldPx / fraction) / Math.LN2);
        }

        var ne = bounds.getNorthEast();
        var sw = bounds.getSouthWest();

        var latFraction = (_latRad(ne.lat()) - _latRad(sw.lat())) / Math.PI;

        var lngDiff = ne.lng() - sw.lng();
        var lngFraction = ((lngDiff < 0) ? (lngDiff + 360) : lngDiff) / 360;

        var latZoom = _zoom(mapWidth, WORLD_DIM.height, latFraction);
        var lngZoom = _zoom(mapWidth, WORLD_DIM.width, lngFraction);

        return Math.min(latZoom, lngZoom, ZOOM_MAX);
    };

    var getCombinedBounds = function (bounds) {
        var bBounds = bounds[0];
        for (var i = 1; i < bounds.length; i++) {
            bBounds.extend(bounds[i].getNorthEast());
            bBounds.extend(bounds[i].getSouthWest());
        }
        return bBounds;
    };

    var getMapConversionInfo = function () {

        var projection = $scope.map.getProjection();

        var bounds = $scope.map.getBounds();
        var topRight = projection.fromLatLngToPoint(bounds.getNorthEast());
        var bottomLeft = projection.fromLatLngToPoint(bounds.getSouthWest());

        var topLeft = new google.maps.Point(bottomLeft.x, topRight.y);
        var projectedWidth = topRight.x - bottomLeft.x;
        var projectedHeight = bottomLeft.y - topRight.y;

        var container = document.getElementById('gmap-canvas');
        var xScale = parseInt(container.offsetWidth) / projectedWidth;
        var yScale = parseInt(container.offsetHeight) / projectedHeight;

        return {
            "xScale": xScale,
            "yScale": yScale,
            "origin": topLeft,
            "projection": projection,
            "width": container.offsetWidth
        };
    };

    var getXYcoords = function (mapInfo, latLng) {

        var worldPoint = mapInfo.projection.fromLatLngToPoint(latLng);
        return [
            (worldPoint.x - mapInfo.origin.x) * mapInfo.xScale,
            (worldPoint.y - mapInfo.origin.y) * mapInfo.yScale
        ];
    };
    var findPolylineBounds = function (polylineData) {
        if (polylineData[0]) {
            var latMax = polylineData[0].coords[0].lat,
                lngMax = polylineData[0].coords[0].lng,
                latMin = polylineData[0].coords[0].lat,
                lngMin = polylineData[0].coords[0].lng;

            polylineData.forEach(function (polyline) {
                var coords = polyline['coords'];
                for (var i = 0; i < coords.length; i++) {
                    if (coords[i].lat < latMax) {
                        latMax = coords[i].lat;
                    }
                    if (coords[i].lat > latMin) {
                        latMin = coords[i].lat;
                    }
                    if (coords[i].lng > lngMax) {
                        lngMax = coords[i].lng;
                    }
                    if (coords[i].lng < lngMin) {
                        lngMin = coords[i].lng;
                    }
                }
            });

            var boundingRect = new google.maps.LatLngBounds(
                new google.maps.LatLng(latMin, lngMin),
                new google.maps.LatLng(latMax, lngMax)
            );

            var center = boundingRect.getCenter();
            var d2sw = getLatLonDistanceInKm(center.lat(), center.lng(), latMin, lngMin);
            return getSquareBoundingBox(center, d2sw + 0.2);
        } else {
            return undefined;
        }
    };

    var getLatLonDistanceInKm = function (lat1, lon1, lat2, lon2) {

        var deg2rad = function (deg) {
            return deg * (Math.PI / 180)
        };

        var R = 6371; // Radius of the earth in km
        var dLat = deg2rad(lat2 - lat1);  // deg2rad below
        var dLon = deg2rad(lon2 - lon1);
        var a =
            Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
            Math.sin(dLon / 2) * Math.sin(dLon / 2);

        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        var d = R * c; // Distance in km

        return d;
    };

    var getSquareBoundingBox = function (centerPoint, distance) {
        /**
         * @param {number} distance - distance (km) from the point represented by centerPoint
         * @param {google.maps.Point} centerPoint - two-dimensional array containing center coords [latitude, longitude]
         * @description
         *   Computes the bounding coordinates of all points on the surface of a sphere
         *   that has a great circle distance to the point represented by the centerPoint
         *   argument that is less or equal to the distance argument.
         *   Technique from: Jan Matuschek <http://JanMatuschek.de/LatitudeLongitudeBoundingCoordinates>
         * @author Alex Salisbury
         */
        var MIN_LAT,
            MAX_LAT,
            MIN_LNG,
            MAX_LNG,
            R,
            radDist,
            degLat,
            degLon,
            radLat,
            radLon,
            minLat,
            maxLat,
            minLon,
            maxLon,
            deltaLon;

        // helper functions (degrees<â€“>radians)
        Number.prototype.degToRad = function () {
            return this * (Math.PI / 180);
        };

        Number.prototype.radToDeg = function () {
            return (180 * this) / Math.PI;
        };

        // coordinate limits
        MIN_LAT = (-90).degToRad();
        MAX_LAT = (90).degToRad();
        MIN_LNG = (-180).degToRad();
        MAX_LNG = (180).degToRad();

        // Earth's radius (km)
        R = 6378.1;

        // angular distance in radians on a great circle
        radDist = distance / R;

        // center point coordinates (deg)
        degLat = centerPoint.lat();
        degLon = centerPoint.lng();

        // center point coordinates (rad)
        radLat = degLat.degToRad();
        radLon = degLon.degToRad();

        // minimum and maximum latitudes for given distance
        minLat = radLat - radDist;
        maxLat = radLat + radDist;

        // minimum and maximum longitudes for given distance
        minLon = void 0;
        maxLon = void 0;

        // define deltaLon to help determine min and max longitudes
        deltaLon = Math.asin(Math.sin(radDist) / Math.cos(radLat));

        if (minLat > MIN_LAT && maxLat < MAX_LAT) {
            minLon = radLon - deltaLon;
            maxLon = radLon + deltaLon;
            if (minLon < MIN_LNG) {
                minLon = minLon + 2 * Math.PI;
            }
            if (maxLon > MAX_LNG) {
                maxLon = maxLon - 2 * Math.PI;
            }
        } else {
            // a pole is within the given distance
            minLat = Math.max(minLat, MIN_LAT);
            maxLat = Math.min(maxLat, MAX_LAT);
            minLon = MIN_LNG;
            maxLon = MAX_LNG;
        }

        var boundingSquare = new google.maps.LatLngBounds(
            new google.maps.LatLng(minLat.radToDeg(), minLon.radToDeg()),
            new google.maps.LatLng(maxLat.radToDeg(), maxLon.radToDeg())
        );

        return boundingSquare;
    };

    var shorter = function (duration) {
        return duration.replace('Hour', 'Hr');
    };

    var distanceWithMeasure = function (distance) {
        if (Number.isInteger(distance)) {
            if (distance < 1000)
                return distance + ' m';
            else
                return Math.round(distance / 100) / 10 + ' km'
        }
        else
            return distance;
    };

    var prettyDistance = function (distance) {
        return 'Walk: ' + Math.round(distance / 100) / 10 + ' Km'
    };

    var prettyDuration = function (duration) {
        var mins = duration % 60;
        var hrs = (duration - mins) / 60;
        var mString = "";

        if (mins > 1) {
            mString = mins + ' Mins';
        } else if (mins == 1) {
            mString = mins + ' Min';
        }

        if (hrs > 1) {
            return hrs + ' Hrs ' + mString;
        } else if (hrs == 1) {
            return hrs + ' Hr ' + mString;
        }
        return mString;
    };

    $scope.shareImage = function () {
        if ($rootScope.selectedTemplate) {
            document.getElementById('map-results').classList.add('done');
            $scope.renderMemeFinal();
            $scope.showImage = true;
            $rootScope.memeShared = true;
            $rootScope.showTemplates = false;
            scrollToElement('invisible-map-anchor');
            $scope.memeNotSelected = false;
            $scope.canProgressToStage3 = false;
        } else {
            $scope.memeNotSelected = true;
        }
    };

    var initStep2 = function () {

        $rootScope.memeShared = false;
        document.getElementById('step-1').classList.add('done');
        document.getElementById('summary-from').innerText = document.getElementById('start-address').value;
        document.getElementById('summary-to').innerText = document.getElementById('dest-address').value;
        $scope.canProgressToStage2 = false;
    };

    var scrollToElement = function (id) {

        setTimeout(function () {
            $anchorScroll(id);
        }, 10);
    }
});

app.factory('MapService', function () {

    return {
        getDirections: function (travelOptions, mode, callback) {
            var directionsService = new google.maps.DirectionsService();

            var start = new google.maps.LatLng(travelOptions.startLat, travelOptions.startLng);
            var end = new google.maps.LatLng(travelOptions.destLat, travelOptions.destLng);
            var request = {
                origin: start,
                destination: end
            };

            switch (mode) {
                case 'driving':
                    request.travelMode = google.maps.TravelMode.DRIVING;
                    break;
                case 'walking':
                    request.travelMode = google.maps.TravelMode.WALKING;
                    break;
                default:
                    request.travelMode = google.maps.TravelMode.TRANSIT;
            }
            directionsService.route(request, callback);
        }
    };
});;var app = angular.module('bus-meme');

app.controller('NavController', function ($scope, $location, $rootScope) {

    $rootScope.userSignedIn = userSignedIn();

    function userSignedIn() {
        return sessionStorage.getItem('isAuthenticated') === "true";
    }

    $scope.showGallery = function () {
        $location.path('/logan/galleries');
    };

    $scope.showAbout = function () {
        $location.path('/logan/about');
    };

    $scope.signIn = function () {
        $location.path('/admin');
    };
    
    $scope.signOut = function () {
        sessionStorage.setItem('isAuthenticated', "false");
        $rootScope.userSignedIn = false;
        $location.path('/logan');
    };

    $scope.hamburgerClick = function() {
        document.getElementById('tuckedMenu').classList.toggle('custom-menu-tucked');
        document.getElementById('toggle').classList.toggle('x');
    }
});
;var app = angular.module('bus-meme');

app.controller('MemeController', function ($scope, $rootScope, $location, MemeFactory, $anchorScroll) {
    $rootScope.showTemplates = false;
    MemeFactory.getMemeTemplates().then(function (response) {
        $scope.memeTemplates = response.data;
        $rootScope.selectedTemplate = '';

        $scope.memeTemplates = response.data;
    });

    $scope.handleOverlay = function(){
        if (!$rootScope.memeShared){
            $rootScope.showTemplates=true;
            document.getElementById("templates").className="template-selection";
            document.getElementById("map-overlay").className="map-overlay";   
        }
    };
    $scope.setSelectedTemplate = function (template) {
        document.getElementById("meme-validation").innerText = '';
        $rootScope.selectedTemplate = template;
        $scope.renderMemeTemplate();
        $rootScope.showTemplates=false;
        $scope.showTooltip();
    };

    $scope.showTooltip = function(){
        $("#meme-tooltip").show().delay(5000).fadeOut();
    };

    $scope.renderMemeTemplate = function () {
        $('#canvas2').remove();
        $('<canvas>', {'id': 'canvas2'}).insertAfter($('#canvas'));

        var canvas = document.getElementById("canvas2");
        var context = canvas.getContext("2d");
        context.clearRect(0, 0, canvas.width, canvas.height);

        var image = document.getElementById('img-out');
        canvas.width = image.width;
        canvas.height = image.height;

        var topText = $rootScope.selectedTemplate.firstLine;
        var bottomText = $rootScope.selectedTemplate.secondLine;

        context.textAlign = "center";
        context.fillStyle = "white";
        context.strokeStyle = "black";
        context.lineWidth = 2;

        writeTextOnImage(context, topText, canvas.width / 2, 70);
        writeTextOnImage(context, bottomText, canvas.width / 2, canvas.height - 30);
    };

    function scrollToElement(id) {
        setTimeout(function () {
            $anchorScroll(id);
        }, 10);
    }

    function writeTextOnImage(context, text, x, y) {
        var f = 36;
        for (; f >= 0; f -= 1) {
            context.font = "bold " + f + "pt Impact, Charcoal, sans-serif";
            if (context.measureText(text).width < canvas.width - 10) {
                context.fillText(text, x, y);
                context.strokeText(text, x, y);
                break;
            }
        }
    }
});

app.factory('MemeFactory', ['$http', function ($http) {
    return {
        getMemeTemplates: function () {
            return $http.get('/logan/getMemeTemplates');
        },
        saveImageDetails: function (imageDetails) {
            return $http.post('/logan/saveImage', {data: imageDetails});
        },
        getImages: function () {
            return $http.get('/logan/getImages');
        },
        saveUserDetails: function (userDetails) {
            return $http.post('/logan/saveUser', {data: userDetails});
        }
    }
}]);

;var app = angular.module('bus-meme');

app.controller('TimeController', function ($scope, $rootScope, BusMemeConfig) {
    var weekdays = BusMemeConfig.WEEK_DAYS;
    var months = BusMemeConfig.MONTHS_NAME;
    $scope.ampms = BusMemeConfig.TIME_OF_DAY;

    $scope.days = getSevenDays();
    $scope.selectedDate = $scope.days[0];

    $scope.hours = getHours();
    $scope.minutes = getMinutes();
    $scope.walkingOptions = getWalkingOptions();

    setSelectedTime();
       
    $scope.timeOption = 'after';

    $scope.selectedMaxWalk = $scope.walkingOptions[4];

    $rootScope.getMaxWalk = function() { return $scope.selectedMaxWalk.value; }
    $rootScope.getTimeOption = function() { return $scope.timeOption; }

    $rootScope.formattedTimeOption = function(){
        var time = $scope.selectedHour + ':' + $scope.selectedMinute + $scope.selectedAmpm;

        switch( $scope.getTimeOption()){
            case "before":
                return "Arriving Before " + time;
            case "after":
                return "Leaving After " + time;
            case "first":  
                return "First Service"; 
            case "last":  
                return "Last Service"; 
        }
    };
    $rootScope.formattedDate = function(){
        var date = $scope.selectedDate.dateValue;
        
        return weekdays[date.getDay()].substr(0,3) + ' ' + 
               date.getDate() + ' ' + 
               months[date.getMonth()] + ' ' +
               date.getFullYear();
    };
    $rootScope.getSelectedTime = function(){

        var hour = $scope.selectedHour;
        if ($scope.selectedAmpm == 'pm')
            hour += 12;

        return new Date($scope.selectedDate.dateValue.getFullYear(),
                        $scope.selectedDate.dateValue.getMonth(),
                        $scope.selectedDate.dateValue.getDate(),
                        hour,
                        $scope.selectedMinute,
                        0,0);
    };

    function getSevenDays(){
        days = [];

        var date = new Date();
        days.push({label:'Today (' + weekdays[date.getDay()] + ')', dateValue:new Date(date)})
        for (var i = 0; i < 6; i++) {
            date.setDate(date.getDate() + 1);
            days.push({label:getDateDisplayLabel(date), dateValue:new Date(date)});
        }

        return days;
    }

    function getHours(){
        var hours = [];

        for (var i=1; i<=12; i++){
            hours.push(i);
        }

        return hours;
    }

    function getMinutes(){
        var minutes = [];

        for (var i=0; i<12; i++){
            var thisMinute = i * 5;

            if (thisMinute==60) 
                thisMinute = 0;

            minutes.push(twoDigits(thisMinute));
        }

        return minutes;
    }
    function setSelectedTime(){
        var date = new Date();

        var hour = date.getHours();

        var roundedMinute = (Math.ceil(date.getMinutes() / 5) * 5);

        if (roundedMinute == 60) {
            roundedMinute = 0;
            hour++;
        }

        $scope.selectedAmpm = $scope.ampms[0];
        
        if (hour > 11) {
            $scope.selectedAmpm = $scope.ampms[1];
        }
        if (hour > 12) {
            hour = hour - 12;
        }

        if (hour == 0){
            hour = 12;
            $scope.selectedAmpm = $scope.ampms[0];
        
        }

        $scope.selectedMinute = $scope.minutes[roundedMinute / 5];
        $scope.selectedHour = $scope.hours[hour - 1];
    }
    function twoDigits(digit){
        if (digit < 10)
            return '0' + digit.toString();
        return digit.toString();
    }
    function getDateDisplayLabel(date){
        return weekdays[date.getDay()].substr(0,3) + ' ' + 
               date.getDate() + ' ' + 
               months[date.getMonth()] + ' ' +
               date.getFullYear();
    }

    function getWalkingOptions(){
        return [
            {label:'Up to 100m', value:'100'},
            {label:'Up to 250m', value:'250'},
            {label:'Up to 500m', value:'500'},
            {label:'Up to 1km', value:'1000'},
            {label:'Up to 1.5km', value:'1500'},
            {label:'Up to 2km', value:'2000'},
            {label:'Up to 4km', value:'4000'}
        ];
    }
});
;var app = angular.module('bus-meme');

app.controller('GalleryController', function ($scope, $location, MemeFactory, BusMemeConfig) {
    $scope.images = [];
    $scope.travelMode = {driving: true, walking: true};
    $scope.sortOption = 'biggestDifference';

    MemeFactory.getImages().then(function (response) {

        $scope.images = response.data;

        $('#loading-img').hide();

        $scope.images.forEach(function (image) {
            image.imageUrl = "/logan/image/" + image.imageLink;
        });

    });

    $scope.showHomePage = function () {
        $location.path('/logan');
    };

    $scope.formatDistance = function (distance) {
        if (distance < 1000)
            return distance + "m";
        else {
            var distanceInKm = distance / 1000;
            return distanceInKm + "km";
        }
    };

    $scope.formatTravelTime = function (time) {
        var timeInMinutes = time / (60000);
        if (timeInMinutes < 60) {
            return timeInMinutes + " mins";
        }
        else {
            var hours = (timeInMinutes / 60).toFixed(0);
            var minutesLeft = timeInMinutes - (hours * 60);
            return hours + " hrs " + minutesLeft + " mins";
        }
    };

    $scope.getSortingCriteria = function (sortOption) {
        if (sortOption === "biggestDifference")
            return '(otherModeTravelTime / publicModeTravelTime)';
        else return '-' + sortOption;
    };

    $scope.getDateDisplay = function (dbDate) {
        var date = new Date(dbDate);
        var months = BusMemeConfig.MONTHS_NAME;

        return date.getDate() + ' ' +
            months[date.getMonth()] + ' ' +
            date.getFullYear();
    };

    /*pagination*/
    $scope.itemsPerPage = BusMemeConfig.ITEMS_PER_PAGE;
    $scope.currentPage = 0;

    $scope.prevPage = function () {
        if ($scope.currentPage > 0) {
            $scope.currentPage--;
        }
    };

    $scope.prevPageDisabled = function () {
        return $scope.currentPage === 0 ? "disabled" : "";
    };

    $scope.pageCount = function () {
        return Math.ceil($scope.images.length / $scope.itemsPerPage);
    };

    $scope.range = function () {
        var range = [];

        for (var i = 0; i < $scope.pageCount(); i++) {
            range.push(i);
        }

        return range;
    };

    $scope.setPage = function (n) {
        if ((n < 0) || (n > $scope.pageCount()))
            return;
        $scope.currentPage = n;
    };

    $scope.nextPage = function () {
        if ($scope.currentPage < $scope.pageCount() - 1) {
            $scope.currentPage++;
        }
    };

    $scope.nextPageDisabled = function () {
        return $scope.currentPage === $scope.pageCount() - 1 ? "disabled" : "";
    };
});

app.filter('transportMode', function () {
    return function (images, travelMode) {
        if (images.length > 0) {
            return images.filter(function (image) {
                if (image.otherMode === "driving" && travelMode.driving) {
                    return true;
                } else if (image.otherMode === "walking" && travelMode.walking) {
                    return true;
                }
            })
        } else {
            return images;
        }
    };
});

app.filter('offset', function () {
    return function (input, start) {
        start = parseInt(start, 10);
        return input.slice(start);
    };
});;var app = angular.module('bus-meme');

app.controller('AboutController', function ($scope, $location) {
    $scope.faqs = [];

    $scope.showHomePage = function () {
        $location.path('/logan');
    };

    $scope.faqs.push({
        "question": "How does this site work?",
        "answer": "We query the Google Maps and Translink journey planner APIs and then combine the results to make the meme."
    });

    $scope.faqs.push({
        "question": "Who made this site?",
        "answer": "The original concept came from the good folks at the Queensland Community Alliance. The site was put together over a 2 week period by some hard working devs at the Brisbane ThoughtWorks office."
    });

    $scope.faqs.push({
        "question": "I'm from <INSERT CITY>, why doesn't the site accept my address?",
        "answer": "Right now we've limited the site to journeys with at least one of the origin or destination in Logan City"
    });

    $scope.faqs.push({
        "question": "Will you include my city in future releases?",
        "answer": "Short answer: 'YES, maybe, soon', Long answer: please email michael.imelfort@gmail.com with more details about your #publictransportfail."
    });

    $scope.faqs.push({
        "question": "Feature ... doesn't seem to work properly / My question wasn't listed here!!",
        "answer": "Please email michael.imelfort@gmail.com with details about any bugs or  questions."
    });

    /*
    $scope.faqs.push({
        "question": ,
        "answer":
    });
    */

});;var app = angular.module('bus-meme');

app.factory('FacebookService', function (BusMemeConfig) {
    return {
        initialiseFacebook: function(){
            window.fbAsyncInit = function () {
                FB.init({
                    appId: BusMemeConfig.FACEBOOK_APP_ID,
                    xfbml: true,
                    version: 'v2.6'
                });
            };

            var js, fjs = document.getElementsByTagName('script')[0];
            if (document.getElementById('facebook-jssdk')) {
                return;
            }
            js = document.createElement('script');
            js.id = 'facebook-jssdk';
            js.src = "//connect.facebook.net/en_US/sdk.js";
            fjs.parentNode.insertBefore(js, fjs);
        }
    }
});;angular.module('bus-meme.config', [])

.constant('BusMemeConfig', {FACEBOOK_APP_ID:1012467365527290,GOOGLE_MAP_STATIC_URL:'https://maps.googleapis.com/maps/api/staticmap?',ITEMS_PER_PAGE:9,MONTHS_NAME:['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],WEEK_DAYS:['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday'],TIME_OF_DAY:['am','pm'],KM_TO_METER_FACTOR:1000,HASH_TAG:'publictransportfail'})

;;var app = angular.module('bus-meme');

app.controller('ImageViewController', function ($scope, $location, $routeParams, locationUtil) {
    var imageId = $routeParams.image;
    console.log(imageId);
    if (!imageId) {
        $location.path('/logan');
    } else {
        $scope.imageUrl = locationUtil.getLocationPath().replace('/meme', '') + '/image/' + imageId;
    }

    $scope.showHomePage = function () {
        $location.search({});
        $location.path('/logan');
    };

});
;var app = angular.module('bus-meme');

app.controller('ExportController', function ($scope, $http, $location, AuthFactory) {

    $scope.authFail = false;
    $scope.userSignedIn = false;

    $scope.showHomePage = function () {
        $location.path('');
    };

    $scope.userLogin = function () {
        AuthFactory.userLogin($scope.token).then(function (response) {

            if (response.data.isAuthenticated) {
                $scope.authFail = false;
                $scope.userSignedIn = true;
                $location.path('/export');
            }
        }, function(err){
            $scope.authFail = true;
            $scope.userSignedIn = false;
        });
    };

    var dataExport = function (data, modelName) {
        var element = angular.element('<a/>');
        var today = new Date();
        element.attr({
            href: 'data:attachment/csv;charset=utf-8,' + encodeURI(data),
            target: '_blank',
            download: 'bmeme' + '-' + modelName
                      + '-' +  today.getDate() + '-' + (today.getMonth()+1) + '-' + today.getFullYear()
                      + '.csv'
        })[0].click();
    };

    $scope.exportUsers = function() {
        $http.get('/exportUsers?token=' + $scope.token).then(function (response) {
            dataExport(response.data, 'users');
        });
    };
    $scope.exportMemeTemplates = function() {
        $http.get('/exportMemeTemplates?token=' + $scope.token).then(function (response) {
            dataExport(response.data, 'templates');
        });
    };
    $scope.exportImages = function() {
        $http.get('/exportImages?token=' + $scope.token).then(function (response) {
            dataExport(response.data, 'images');
        });
    };

});

app.factory('AuthFactory', ['$http', function ($http) {
    return {
        userLogin: function (token) {
            return $http.post('/userLogin', {data: token});
        }
    }
}]);


;var app = angular.module('bus-meme');

app.controller('SocialMediaController', function ($scope, $rootScope, $location, $route, MemeFactory, locationUtil, BusMemeConfig) {
    $scope.user = {};
    $scope.invalidUserInput = false;

    $scope.downloadCanvas = function () {
        var canvas = document.getElementById("canvas");
        $rootScope.imageUrl = canvas.toDataURL('image/png');

        var dl = document.getElementById('dl');
    };

    function convertToMiliseconds(travelTime) {
        var timeArray = travelTime.split(' ');
        return moment.duration({
            hours: timeArray.length > 2 ? timeArray[0] : 0,
            minutes: timeArray.length === 2 ? timeArray[0] : timeArray[0]
        }).asMilliseconds();
    }

    function convertToMeters(distance) {
        return Number(distance.toLowerCase().replace(' km', '').replace('walk: ', '')) * BusMemeConfig.KM_TO_METER_FACTOR;
    }

    $scope.saveImage = function (callback) {
        if ($rootScope.imageLink) {
            callback($rootScope.imageLink);
        }
        else {
            $scope.downloadCanvas();

            var imageDetails = {
                imageUrl: $rootScope.imageUrl,
                otherMode: $scope.other.mode,
                otherModeTravelTime: convertToMiliseconds($scope.other.duration),
                otherModeTravelDistance: convertToMeters($scope.other.distance),
                publicModeTravelTime: convertToMiliseconds($scope.public.duration),
                publicModeTravelDistance: convertToMeters($scope.public.distance),
                user: $scope.user
            };

            MemeFactory.saveImageDetails(imageDetails).then(function (response) {
                var imageLink = encodeURIComponent(response.data.imageLink);
                $rootScope.imageLink = locationUtil.getLocationPath() + '/image/' + imageLink;
                callback($rootScope.imageLink);
            });
        }
    };

    $scope.facebookShare = function () {
        $scope.saveImage(function (imageLink) {
            FB.ui({
                method: 'share',
                href: imageLink,
                hashtag: '#' + BusMemeConfig.HASH_TAG + " Go to http://busmeme.org",
                quote: $rootScope.memeText
            }, function (response) {
                console.log(response);
            });
        });
    };

    $scope.twitterShare = function () {
        $scope.saveImage(function (imageLink) {

            var tweetLength = 140;
            var tweetText = $rootScope.memeText;
            var hashtag = ' %23' + BusMemeConfig.HASH_TAG;

            if (tweetText.length + imageLink.length + hashtag.length > tweetLength) {
                tweetText = tweetText.substring(0, tweetLength - hashtag.length - imageLink.length - 2) + '..';
            }

            tweetText = tweetText + hashtag;
            window.open("https://twitter.com/intent/tweet?text=" + tweetText + "&url=" + imageLink,
                '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=300,width=600');
        });
    };

    $scope.reloadPage = function () {
        $rootScope.imageLink = '';
        $route.reload();
    };

    function validEmail(email) {
        return /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+$/.test(email);
    }

    function validUser(user) {
        if (user.fullName && user.email) {
            return validEmail(user.email);
        }
    }

    $scope.saveUserDetails = function () {
        $scope.invalidUserInput = !validUser($scope.user);
        if (!$scope.invalidUserInput) {
            MemeFactory.saveUserDetails($scope.user).then(function (response) {
                $scope.subscribed = true;
            });
        }
    }
});
